name: Deploy to AWS

on:
  push:
    branches:
      - main

env:
  AWS_REGION: eu-central-1
  AWS_STACK_NAME: patapon

permissions:
  contents: read

jobs:
  deploy_code:
    name: Deploy Code
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Get resource arns
        id: get-arns
        run: |
          STACK_OUTPUT=$(
            aws cloudformation describe-stacks \
              --region ${{ env.AWS_REGION }} \
              --stack-name ${{ env.AWS_STACK_NAME }} \
              --query 'Stacks[0].Outputs[*].[OutputKey,OutputValue]' \
              --no-paginate \
              --output text
          )

          while IFS= read -r line
          do
            read -r key value <<< $line
            echo "::set-output name=$key::$value"
          done <<< "$STACK_OUTPUT"

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REPOSITORY: ${{ steps.get-arns.outputs.RepositoryName }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build a docker container and push it to ECR
          docker build . --file image-lambda.Dockerfile --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - name: Deploy Lambda function
        id: lambda-function
        env:
          ECR_REPOSITORY: ${{ steps.get-arns.outputs.RepositoryName }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          LAMBDA_EXECUTION_ROLE: ${{ steps.get-arns.outputs.LambdaExecutionRoleArn }}
          IMAGE_TAG: ${{ github.sha }}
          ENV_DOMAIN_NAME: nitrotemplate
          ENV_SUPABASE_KEY: example
          ENV_SUPABASE_URL: example

        run: |
          LAMBDA_OUTPUT=$(
            aws lambda create-function \
              --function-name $IMAGE_TAG \
              --code ImageUri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
              --role $LAMBDA_EXECUTION_ROLE \
              --package-type Image \
              --environment Variables="{DOMAIN_NAME=$ENV_DOMAIN_NAME,SUPABASE_KEY=$ENV_SUPABASE_KEY,SUPABASE_URL=$ENV_SUPABASE_URL}" \
              --publish
          )

          echo $LAMBDA_OUTPUT

          LAMBDA_ARN=$(node -pe 'JSON.parse(process.argv[1]).FunctionArn' $LAMBDA_OUTPUT)

          echo $LAMBDA_ARN

          aws lambda add-permission \
            --function-name $LAMBDA_ARN \
            --action lambda:InvokeFunction \
            --principal elasticloadbalancing.amazonaws.com \
            --statement-id $IMAGE_TAG

          echo "::set-output name=LAMBDA_ARN::$LAMBDA_ARN"

      - name: Register a target group
        id: register-target-group
        env:
          TARGET_GROUP_ARN: ${{ steps.get-arns.outputs.TargetGroupArn }}
          LAMBDA_ARN: ${{ steps.lambda-function.outputs.LAMBDA_ARN }}
        run: |
          PREV_LAMBDA_ID=$(aws elbv2 describe-target-health --target-group-arn $TARGET_GROUP --query 'TargetHealthDescriptions[0].Target.Id')

          aws elbv2 deregister-targets \
          --target-group-arn $TARGET_GROUP \
          --targets Id=$PREV_LAMBDA_ID

          aws elbv2 register-targets \
            --target-group-arn $TARGET_GROUP \
            --targets Id=$LAMBDA_ARN
